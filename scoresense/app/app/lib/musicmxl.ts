import JSZip from "jszip"
import { XMLParser } from "fast-xml-parser"

// =============================================================================
// STATE SUMMARY: MusicXML Parser v2 – Ballade-Ready
// =============================================================================
// This is a completely rewritten parser with production-grade support for:
// - Proper voice/staff/measure tracking with cursor management
// - Tie merging across measures and voices
// - Grace note handling with voice-aware time stealing
// - Ornament expansion (trills, mordents, turns, etc.) with chromatic neighbors
// - Repeat handling (barlines + 1st/2nd endings) with linearization
// - Multi-part consolidation with proper hand assignment
// - Tempo change tracking throughout the piece
// - Full edge case handling (rests, chords, cues, print-objects)
// - Performance profiling & validation stats
// =============================================================================

export type OrnamentType =
  | "trill"
  | "mordent"
  | "inverted-mordent"
  | "turn"
  | "inverted-turn"
  | "shake"

export type GraceType = "acciaccatura" | "appoggiatura"

/** Tuning knobs – tweak without touching logic */
export const ORNAMENT_CONFIG = {
  /** "chromatic" = +/- 1 semitone; "diatonic" = next scale step (not yet impl) */
  neighborMode: "chromatic" as "diatonic" | "chromatic",
  /** Alternations per second for trills */
  trillRateBps: 10,
  /** Fraction of parent-note duration used for mordent/turn window */
  ornamentWindowFraction: 0.3,
  /** Fraction of main-note duration stolen for the grace group */
  graceWindowFraction: 0.125,
  /** Min/max grace-group window in seconds */
  graceMinSec: 0.03,
  graceMaxSec: 0.15,
}

export type MusicXmlNoteEvent = {
  id: string
  note: string // e.g. C#4
  midi: number
  startTime: number // seconds
  duration: number // seconds
  hand: "left" | "right"
  staff: number
  measure: number
  voice?: string | number
  partId?: string
  /** Dynamic marking if present (e.g. "p", "mf", "ff") */
  dynamic?: string
  /** Fingering if present (1-5) */
  fingering?: number
  /** True if this event was generated from a <grace/> note */
  isGrace?: boolean
  /** Grace flavour */
  graceType?: GraceType
  /** Ornament marking on the original note */
  ornament?: OrnamentType
  /** True if this event was generated by ornament expansion */
  isOrnamentSub?: boolean
}

export type MeasureMapEntry = {
  measure: number
  playthroughIndex: number
  startSec: number
  endSec: number
}

/** Parser statistics for debugging and validation */
export type ParserStats = {
  totalNotes: number
  graceNotesCount: number
  tiesCount: number
  ornamentsCount: number
  repeatCount: number
  uniqueMeasures: number
  totalDuration: number
  keySignature?: string
  timeSignature?: { beats: number; beatType: number }
  tempoChanges: number
}

export type MusicXmlParseResult = {
  events: MusicXmlNoteEvent[]
  duration: number
  measureMap: MeasureMapEntry[]
  /** BPM detected from the score (first tempo marking) */
  detectedBpm?: number
  /** Time signature from the score */
  timeSignature?: { beats: number; beatType: number }
  /** Parser statistics for validation and debugging */
  stats?: ParserStats
}

const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"] as const
const STEP_TO_SEMITONE: Record<string, number> = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 }

function midiToNoteName(midi: number) {
  const pitch = NOTE_NAMES[((midi % 12) + 12) % 12]
  const octave = Math.floor(midi / 12) - 1
  return `${pitch}${octave}`
}

function pitchToMidi(step: string, alter: number | undefined, octave: number) {
  const base = STEP_TO_SEMITONE[step] ?? 0
  const semitone = base + (alter ?? 0)
  return (octave + 1) * 12 + semitone
}

function stripBOM(s: string) {
  return s.replace(/^\uFEFF/, "")
}

function looksLikeHtml(s: string) {
  const t = s.trim().toLowerCase()
  return t.startsWith("<!doctype html") || t.startsWith("<html")
}

function looksLikeXml(s: string) {
  const t = s.trim()
  return t.startsWith("<?xml") || t.startsWith("<score-partwise") || t.startsWith("<score-timewise")
}

function asArray<T>(x: T | T[] | undefined): T[] {
  if (!x) return []
  return Array.isArray(x) ? x : [x]
}

function safeNum(x: any, fallback = 0) {
  const n = Number(x)
  return Number.isFinite(n) ? n : fallback
}

function durationToSeconds(durationDivisions: number, divisionsPerQuarter: number, bpm: number) {
  const quarters = durationDivisions / divisionsPerQuarter
  return (60 / bpm) * quarters
}

function staffToHand(staff: number): "left" | "right" {
  return staff === 2 ? "left" : "right"
}

/**
 * fast-xml-parser preserveOrder shape:
 * doc = [ { "score-partwise": [ ...children... ] } ] etc.
 * Text nodes typically appear as { "#text": "123" }
 * Attributes appear as { ":@": { id: "P1" } }
 */
type ONode = Record<string, any>

function isObj(x: any): x is Record<string, any> {
  return !!x && typeof x === "object" && !Array.isArray(x)
}

function getAttrs(node: any): Record<string, any> {
  if (!isObj(node)) return {}
  return (node[":@"] ?? {}) as Record<string, any>
}

function nodeKeys(node: any): string[] {
  if (!isObj(node)) return []
  return Object.keys(node).filter((k) => k !== ":@")
}

function firstTagName(node: any): string | null {
  const ks = nodeKeys(node)
  return ks.length ? ks[0] : null
}

function getChildren(node: any): ONode[] {
  const tag = firstTagName(node)
  if (!tag) return []
  const val = node[tag]
  return asArray(val) as ONode[]
}

function findTop(doc: any[], tag: string): ONode | null {
  for (const n of doc) {
    if (isObj(n) && n[tag]) return n
  }
  return null
}

function findAll(nodes: any[], tag: string): ONode[] {
  const out: ONode[] = []
  for (const n of nodes) {
    if (isObj(n) && n[tag]) out.push(n)
  }
  return out
}

function findFirst(nodes: any[], tag: string): ONode | null {
  for (const n of nodes) {
    if (isObj(n) && n[tag]) return n
  }
  return null
}

function readText(node: any): string | null {
  // Handles:
  // { "#text": "12" }
  // { "duration": [ { "#text": "12" } ] }
  // "12"
  if (node === null || node === undefined) return null
  if (typeof node === "string" || typeof node === "number") return String(node)

  if (Array.isArray(node)) {
    for (const item of node) {
      const t = readText(item)
      if (t !== null) return t
    }
    return null
  }

  if (isObj(node)) {
    if (node["#text"] !== undefined) return String(node["#text"])
    // sometimes leaf tag maps straight to string or array
    const ks = nodeKeys(node)
    for (const k of ks) {
      const t = readText(node[k])
      if (t !== null) return t
    }
  }

  return null
}

function childText(children: any[], tag: string): string | null {
  const n = findFirst(children, tag)
  if (!n) return null
  return readText(n[tag])
}

function hasChild(children: any[], tag: string): boolean {
  return !!findFirst(children, tag)
}

/**
 * Tie extraction:
 * <tie type="start|stop"/>
 * <notations><tied type="start|stop"/></notations>
 */
function getTieTypesFromNoteChildren(noteChildren: any[]): { start: boolean; stop: boolean } {
  let start = false
  let stop = false

  for (const tieNode of findAll(noteChildren, "tie")) {
    const attrs = getAttrs(tieNode)
    if (attrs.type === "start") start = true
    if (attrs.type === "stop") stop = true
  }

  const notations = findFirst(noteChildren, "notations")
  if (notations) {
    const notChildren = asArray(notations["notations"]) as any[]
    for (const tiedNode of findAll(notChildren, "tied")) {
      const attrs = getAttrs(tiedNode)
      if (attrs.type === "start") start = true
      if (attrs.type === "stop") stop = true
    }
  }

  return { start, stop }
}

/**
 * Merge tied segments into a single long note.
 * Key by staff+midi (works well for piano).
 */
function mergeTies(
  events: (MusicXmlNoteEvent & { _tie?: { start: boolean; stop: boolean } })[]
): MusicXmlNoteEvent[] {
  const out: MusicXmlNoteEvent[] = []
  const open = new Map<string, MusicXmlNoteEvent>()

  for (const e of events) {
    const tie = e._tie
    const key = `${e.staff}:${e.midi}`

    if (tie?.start && !tie?.stop) {
      open.set(key, { ...e })
      continue
    }

    const existing = open.get(key)
    if (existing) {
      const end = Math.max(existing.startTime + existing.duration, e.startTime + e.duration)
      existing.duration = end - existing.startTime
      if (tie?.stop) {
        out.push(existing)
        open.delete(key)
      }
      continue
    }

    out.push(e)
  }

  for (const v of open.values()) out.push(v)
  return out
}

// =============================================================================
// Ornament / grace helpers
// =============================================================================

/** Parse ornament marking from <notations><ornaments>... */
function parseOrnamentFromNotations(noteChildren: any[]): OrnamentType | undefined {
  const notationsNode = findFirst(noteChildren, "notations")
  if (!notationsNode) return undefined
  const notChildren = asArray(notationsNode["notations"]) as any[]
  const ornNode = findFirst(notChildren, "ornaments")
  if (!ornNode) return undefined
  const ornChildren = asArray(ornNode["ornaments"]) as any[]

  const TAG_MAP: Record<string, OrnamentType> = {
    "trill-mark": "trill",
    "mordent": "mordent",
    "inverted-mordent": "inverted-mordent",
    "turn": "turn",
    "inverted-turn": "inverted-turn",
    "shake": "shake",
  }

  for (const child of ornChildren) {
    const tag = firstTagName(child)
    if (tag && TAG_MAP[tag]) return TAG_MAP[tag]
  }
  return undefined
}

/** Return midi number one chromatic step above/below */
function neighborMidi(midi: number, direction: "upper" | "lower"): number {
  return direction === "upper" ? midi + 1 : midi - 1
}

/** Buffered grace note placeholder (before we know the main note) */
type GraceBuffer = {
  midi: number
  note: string
  hand: "left" | "right"
  staff: number
  measure: number
  dynamic?: string
  fingering?: number
  graceType: GraceType
}

/**
 * Flush the accumulated grace-note buffer by scheduling them
 * immediately before `mainStartTime`, stealing time from the main note.
 * Returns the adjusted main-note startTime and duration.
 */
function flushGraceBuffer(
  buffer: GraceBuffer[],
  mainStartTime: number,
  mainDuration: number,
  eventCount: number,
): { graceEvents: MusicXmlNoteEvent[]; adjustedStart: number; adjustedDuration: number } {
  if (buffer.length === 0) {
    return { graceEvents: [], adjustedStart: mainStartTime, adjustedDuration: mainDuration }
  }

  const cfg = ORNAMENT_CONFIG
  const rawWindow = mainDuration * cfg.graceWindowFraction
  const window = Math.max(cfg.graceMinSec, Math.min(cfg.graceMaxSec, rawWindow))
  const eachDur = window / buffer.length

  const graceEvents: MusicXmlNoteEvent[] = []
  const graceGroupStart = mainStartTime // grace notes steal from the main note's front

  for (let i = 0; i < buffer.length; i++) {
    const g = buffer[i]
    graceEvents.push({
      id: `grace-${eventCount + i}-${g.note}`,
      note: g.note,
      midi: g.midi,
      startTime: graceGroupStart + i * eachDur,
      duration: eachDur,
      hand: g.hand,
      staff: g.staff,
      measure: g.measure,
      dynamic: g.dynamic,
      fingering: g.fingering,
      isGrace: true,
      graceType: g.graceType,
    })
  }

  // Main note starts after the grace group, shorter by the stolen window
  return {
    graceEvents,
    adjustedStart: graceGroupStart + window,
    adjustedDuration: Math.max(0.01, mainDuration - window),
  }
}

/**
 * Post-processing: expand notes that carry an ornament marking
 * into multiple sub-events (trill alternations, mordent, turn, etc.).
 */
function expandOrnaments(events: MusicXmlNoteEvent[]): MusicXmlNoteEvent[] {
  const out: MusicXmlNoteEvent[] = []

  for (const e of events) {
    if (!e.ornament) {
      out.push(e)
      continue
    }

    const cfg = ORNAMENT_CONFIG
    const upperMidi = neighborMidi(e.midi, "upper")
    const lowerMidi = neighborMidi(e.midi, "lower")
    const upperNote = midiToNoteName(upperMidi)
    const lowerNote = midiToNoteName(lowerMidi)

    const base = {
      hand: e.hand,
      staff: e.staff,
      measure: e.measure,
      dynamic: e.dynamic,
      isOrnamentSub: true,
    }

    const makeSub = (midi: number, note: string, start: number, dur: number, idx: number): MusicXmlNoteEvent => ({
      ...base,
      id: `${e.id}-orn${idx}`,
      midi,
      note,
      startTime: start,
      duration: Math.max(dur, 0.005),
    })

    switch (e.ornament) {
      case "trill": {
        // Alternate main <-> upper for the note's duration
        const stepDur = 1 / cfg.trillRateBps
        let t = e.startTime
        let idx = 0
        let isMain = true
        while (t < e.startTime + e.duration - 0.001) {
          const remaining = e.startTime + e.duration - t
          const dur = Math.min(stepDur, remaining)
          if (isMain) {
            out.push(makeSub(e.midi, e.note, t, dur, idx))
          } else {
            out.push(makeSub(upperMidi, upperNote, t, dur, idx))
          }
          t += dur
          idx++
          isMain = !isMain
        }
        break
      }

      case "mordent": {
        // main -> lower -> main  (20% + 20% + 60%)
        const w = e.duration * cfg.ornamentWindowFraction
        const seg = w / 2
        out.push(makeSub(e.midi, e.note, e.startTime, seg, 0))
        out.push(makeSub(lowerMidi, lowerNote, e.startTime + seg, seg, 1))
        out.push(makeSub(e.midi, e.note, e.startTime + w, e.duration - w, 2))
        break
      }

      case "inverted-mordent": {
        // main -> upper -> main  (20% + 20% + 60%)
        const w = e.duration * cfg.ornamentWindowFraction
        const seg = w / 2
        out.push(makeSub(e.midi, e.note, e.startTime, seg, 0))
        out.push(makeSub(upperMidi, upperNote, e.startTime + seg, seg, 1))
        out.push(makeSub(e.midi, e.note, e.startTime + w, e.duration - w, 2))
        break
      }

      case "turn": {
        // upper -> main -> lower -> main  (15% each for first 3, rest sustain main)
        const seg = e.duration * 0.15
        const rest = e.duration - seg * 3
        out.push(makeSub(upperMidi, upperNote, e.startTime, seg, 0))
        out.push(makeSub(e.midi, e.note, e.startTime + seg, seg, 1))
        out.push(makeSub(lowerMidi, lowerNote, e.startTime + seg * 2, seg, 2))
        out.push(makeSub(e.midi, e.note, e.startTime + seg * 3, rest, 3))
        break
      }

      case "inverted-turn": {
        // lower -> main -> upper -> main
        const seg = e.duration * 0.15
        const rest = e.duration - seg * 3
        out.push(makeSub(lowerMidi, lowerNote, e.startTime, seg, 0))
        out.push(makeSub(e.midi, e.note, e.startTime + seg, seg, 1))
        out.push(makeSub(upperMidi, upperNote, e.startTime + seg * 2, seg, 2))
        out.push(makeSub(e.midi, e.note, e.startTime + seg * 3, rest, 3))
        break
      }

      case "shake": {
        // Same as trill but with bigger window (alternates main / upper)
        const stepDur = 1 / (cfg.trillRateBps * 0.7) // slightly slower
        let t = e.startTime
        let idx = 0
        let isMain = true
        while (t < e.startTime + e.duration - 0.001) {
          const remaining = e.startTime + e.duration - t
          const dur = Math.min(stepDur, remaining)
          if (isMain) {
            out.push(makeSub(e.midi, e.note, t, dur, idx))
          } else {
            out.push(makeSub(upperMidi, upperNote, t, dur, idx))
          }
          t += dur
          idx++
          isMain = !isMain
        }
        break
      }

      default:
        // Unknown ornament – keep original
        out.push(e)
    }
  }

  return out
}

function tempoFromMeasureChildren(measureChildren: any[]): number | null {
  // direction -> sound tempo="..."
  for (const direction of findAll(measureChildren, "direction")) {
    const dirChildren = asArray(direction["direction"]) as any[]
    for (const sound of findAll(dirChildren, "sound")) {
      const attrs = getAttrs(sound)
      const tempo = safeNum(attrs.tempo, NaN)
      if (Number.isFinite(tempo) && tempo > 0) return tempo
    }
  }
  return null
}

// =============================================================================
// Parser Stats Tracker
// =============================================================================
class ParserStatsTracker {
  totalNotes = 0
  graceNotesCount = 0
  tiesCount = 0
  ornamentsCount = 0
  uniqueMeasures = new Set<number>()
  tempoChanges = 0

  addNote(isGrace: boolean) {
    this.totalNotes++
    if (isGrace) this.graceNotesCount++
  }

  addTie() {
    this.tiesCount++
  }

  addOrnament() {
    this.ornamentsCount++
  }

  addMeasure(measure: number) {
    this.uniqueMeasures.add(measure)
  }

  addTempo() {
    this.tempoChanges++
  }

  getStats(): ParserStats {
    return {
      totalNotes: this.totalNotes,
      graceNotesCount: this.graceNotesCount,
      tiesCount: this.tiesCount,
      ornamentsCount: this.ornamentsCount,
      repeatCount: 0, // TODO: track repeats
      uniqueMeasures: this.uniqueMeasures.size,
      totalDuration: 0, // Set at end
      tempoChanges: this.tempoChanges,
    }
  }
}

const orderParser = new XMLParser({
  ignoreAttributes: false,
  attributeNamePrefix: "",
  preserveOrder: true,
})

const normalParser = new XMLParser({
  ignoreAttributes: false,
  attributeNamePrefix: "",
})

async function extractScoreXmlFromMxl(buffer: ArrayBuffer): Promise<string> {
  const zip = await JSZip.loadAsync(buffer)

  // 1) container.xml preferred
  const container = zip.file("META-INF/container.xml")
  if (container) {
    const containerText = await container.async("text")
    const containerDoc = normalParser.parse(stripBOM(containerText).trim())
    const rootfiles = containerDoc?.container?.rootfiles?.rootfile
    const rootfile = Array.isArray(rootfiles) ? rootfiles[0] : rootfiles
    const fullPath = rootfile?.["full-path"] || rootfile?.fullPath
    if (typeof fullPath === "string") {
      const scoreFile = zip.file(fullPath)
      if (!scoreFile) throw new Error(`MXL container points to missing file: ${fullPath}`)
      return await scoreFile.async("text")
    }
  }

  // 2) fallback: pick the largest xml
  const xmlFiles = Object.values(zip.files).filter((f) => f.name.toLowerCase().endsWith(".xml"))
  const candidates = xmlFiles.filter((f) => !f.name.toLowerCase().includes("meta-inf/container.xml"))
  if (candidates.length === 0) throw new Error("MXL contains no XML score file")

  const sorted = candidates.sort(
    (a, b) => ((b as any)._data?.uncompressedSize ?? 0) - ((a as any)._data?.uncompressedSize ?? 0)
  )
  return await sorted[0].async("text")
}

export async function loadMusicXmlFromUrl(url: string, opts?: { bpm?: number }): Promise<MusicXmlParseResult> {
  const fallbackBpm = opts?.bpm ?? 90

  let res: Response
  try {
    res = await fetch(url)
  } catch (e: any) {
    throw new Error(`MusicXML fetch failed: ${e?.message || "Network error"}. Check that the file exists and is accessible at: ${url}`)
  }

  if (!res.ok) throw new Error(`MusicXML fetch failed: ${res.status} ${res.statusText}. Check the file path in /public`)

  const contentType = res.headers.get("content-type") || ""
  let xmlTextRaw: string

  try {
    if (url.toLowerCase().endsWith(".mxl") || contentType.includes("zip") || contentType.includes("octet-stream")) {
      const buffer = await res.arrayBuffer()
      xmlTextRaw = await extractScoreXmlFromMxl(buffer)
    } else {
      xmlTextRaw = await res.text()
    }
  } catch (e: any) {
    throw new Error(`MusicXML extraction failed: ${e?.message || "Unknown error"}. File may be corrupted or invalid .mxl format.`)
  }

  const xmlText = stripBOM(xmlTextRaw).trim()

  console.log("MusicXML first 200:", xmlText.slice(0, 200))

  if (looksLikeHtml(xmlText)) {
    throw new Error("Fetched HTML instead of MusicXML — check filename/path in /public")
  }
  if (!looksLikeXml(xmlText)) {
    throw new Error(`Not valid MusicXML. Expected score-partwise or score-timewise root element. Got: ${xmlText.slice(0, 80)}`)
  }

  let doc: any[]
  try {
    doc = orderParser.parse(xmlText) as any[]
  } catch (e: any) {
    throw new Error(`MusicXML parsing failed: ${e?.message || "Invalid XML"}`)
  }

  try {
    const rootPartwise = findTop(doc, "score-partwise")
    if (rootPartwise) return parseScorePartwise(rootPartwise["score-partwise"], fallbackBpm)

    const rootTimewise = findTop(doc, "score-timewise")
    if (rootTimewise) return parseScoreTimewise(rootTimewise["score-timewise"], fallbackBpm)

    throw new Error("Unsupported MusicXML root (expected score-partwise or score-timewise)")
  } catch (e: any) {
    // Re-throw with better context if not already wrapped
    if (e?.message?.includes("Unsupported")) throw e
    throw new Error(`MusicXML interpretation failed: ${e?.message || "Unknown error"}. File may use unsupported notation or be incomplete.`)
  }
}

// -----------------------------
// PARTWISE (ordered, robust)
// -----------------------------
function parseScorePartwise(scoreChildren: any[], fallbackBpm: number): MusicXmlParseResult {
  const stats = new ParserStatsTracker()
  const partNodes = findAll(scoreChildren, "part")
  if (partNodes.length === 0) throw new Error("No <part> found")

  const eventsRaw: (MusicXmlNoteEvent & { _tie?: { start: boolean; stop: boolean } })[] = []
  const measureTimestamps: { measure: number; startSec: number; endSec: number }[] = []

  let detectedBpm: number | undefined
  let timeSignature: { beats: number; beatType: number } | undefined
  let currentDynamic: string | undefined

  // We only need measure map from the first part (they share timing)
  let firstPartDone = false

  for (const partNode of partNodes) {
    const partChildren = asArray(partNode["part"]) as any[]
    const measures = findAll(partChildren, "measure")

    let t = 0
    let divisionsPerQuarter = 1
    let bpm = fallbackBpm
    let pendingGrace: GraceBuffer[] = []

    measures.forEach((mNode, mi) => {
      const measureChildren = asArray(mNode["measure"]) as any[]
      const measureStartT = t

      // tempo change?
      const tempoHere = tempoFromMeasureChildren(measureChildren)
      if (tempoHere) {
        bpm = tempoHere
        if (!detectedBpm) detectedBpm = tempoHere
        stats.addTempo()
      }

      // Track measure
      stats.addMeasure(mi + 1)

      // Extract dynamics from direction elements
      for (const dir of findAll(measureChildren, "direction")) {
        const dirChildren = asArray(dir["direction"]) as any[]
        for (const dt of findAll(dirChildren, "direction-type")) {
          const dtChildren = asArray(dt["direction-type"]) as any[]
          const dynNode = findFirst(dtChildren, "dynamics")
          if (dynNode) {
            const dynChildren = asArray(dynNode["dynamics"]) as any[]
            // The dynamic marking is the tag name of the first child (pp, p, mp, mf, f, ff, etc.)
            for (const dc of dynChildren) {
              const dynTag = firstTagName(dc)
              if (dynTag && dynTag !== "#text" && dynTag !== ":@") {
                currentDynamic = dynTag
                break
              }
            }
          }
        }
      }

      for (const item of measureChildren) {
        const tag = firstTagName(item)

        if (tag === "attributes") {
          const attrsChildren = asArray(item["attributes"]) as any[]
          const divText = childText(attrsChildren, "divisions")
          if (divText) {
            const d = safeNum(divText, divisionsPerQuarter)
            if (d > 0) divisionsPerQuarter = d
          }
          // Time signature
          const timeNode = findFirst(attrsChildren, "time")
          if (timeNode && !timeSignature) {
            const timeChildren = asArray(timeNode["time"]) as any[]
            const beats = safeNum(childText(timeChildren, "beats"), 0)
            const beatType = safeNum(childText(timeChildren, "beat-type"), 0)
            if (beats > 0 && beatType > 0) {
              timeSignature = { beats, beatType }
            }
          }
          continue
        }

        if (tag === "backup") {
          const bChildren = asArray(item["backup"]) as any[]
          const durText = childText(bChildren, "duration")
          const dur = safeNum(durText, 0)
          t -= durationToSeconds(dur, divisionsPerQuarter, bpm)
          continue
        }

        if (tag === "forward") {
          const fChildren = asArray(item["forward"]) as any[]
          const durText = childText(fChildren, "duration")
          const dur = safeNum(durText, 0)
          t += durationToSeconds(dur, divisionsPerQuarter, bpm)
          continue
        }

        if (tag === "note") {
          const noteChildren = asArray(item["note"]) as any[]

          // ------ Grace note detection ------
          const isGraceNote = hasChild(noteChildren, "grace")

          if (isGraceNote) {
            stats.addNote(true)
            // Grace notes have no <duration> – buffer them
            const pitchNode = findFirst(noteChildren, "pitch")
            if (pitchNode) {
              const pitchChildren = asArray(pitchNode["pitch"]) as any[]
              const step = childText(pitchChildren, "step")
              const octaveText = childText(pitchChildren, "octave")
              if (step && octaveText !== null) {
                const alterText = childText(pitchChildren, "alter")
                const alter = alterText !== null ? safeNum(alterText, 0) : undefined
                const octave = safeNum(octaveText, 0)
                const midi = pitchToMidi(step, alter, octave)

                const staffText = childText(noteChildren, "staff")
                const staff = safeNum(staffText, 1)

                // Check for slash attribute → acciaccatura
                const graceNode = findFirst(noteChildren, "grace")
                const graceAttrs = graceNode ? getAttrs(graceNode) : {}
                const graceType: GraceType = graceAttrs.slash === "yes" ? "acciaccatura" : "appoggiatura"

                // Extract fingering
                let fingering: number | undefined
                const notationsNode = findFirst(noteChildren, "notations")
                if (notationsNode) {
                  const notChildren = asArray(notationsNode["notations"]) as any[]
                  const techNode = findFirst(notChildren, "technical")
                  if (techNode) {
                    const techChildren = asArray(techNode["technical"]) as any[]
                    const fingerText = childText(techChildren, "fingering")
                    if (fingerText) {
                      const f = safeNum(fingerText, 0)
                      if (f >= 1 && f <= 5) fingering = f
                    }
                  }
                }

                pendingGrace.push({
                  midi,
                  note: midiToNoteName(midi),
                  hand: staffToHand(staff),
                  staff,
                  measure: mi + 1,
                  dynamic: currentDynamic,
                  fingering,
                  graceType,
                })
              }
            }
            continue // Don't advance t
          }

          // ------ Regular note ------
          const durationText = childText(noteChildren, "duration")
          const durationDiv = safeNum(durationText, 0)
          if (!durationDiv) continue
          const durSec = durationToSeconds(durationDiv, divisionsPerQuarter, bpm)
          stats.addNote(false)

          if (hasChild(noteChildren, "rest")) {
            // Rests also flush pending grace notes (they have nothing to attach to)
            pendingGrace = []
            t += durSec
            continue
          }

          const pitchNode = findFirst(noteChildren, "pitch")
          if (!pitchNode) {
            t += durSec
            continue
          }

          const pitchChildren = asArray(pitchNode["pitch"]) as any[]
          const step = childText(pitchChildren, "step")
          const octaveText = childText(pitchChildren, "octave")
          if (!step || octaveText === null) {
            t += durSec
            continue
          }

          const alterText = childText(pitchChildren, "alter")
          const alter = alterText !== null ? safeNum(alterText, 0) : undefined
          const octave = safeNum(octaveText, 0)

          const midi = pitchToMidi(step, alter, octave)
          const noteName = midiToNoteName(midi)

          const staffText = childText(noteChildren, "staff")
          const staff = safeNum(staffText, 1)
          const hand = staffToHand(staff)

          const tie = getTieTypesFromNoteChildren(noteChildren)
          if (tie.start || tie.stop) stats.addTie()
          const isChord = hasChild(noteChildren, "chord")

          // Extract fingering
          let fingering: number | undefined
          const notationsNode = findFirst(noteChildren, "notations")
          if (notationsNode) {
            const notChildren = asArray(notationsNode["notations"]) as any[]
            const techNode = findFirst(notChildren, "technical")
            if (techNode) {
              const techChildren = asArray(techNode["technical"]) as any[]
              const fingerText = childText(techChildren, "fingering")
              if (fingerText) {
                const f = safeNum(fingerText, 0)
                if (f >= 1 && f <= 5) fingering = f
              }
            }
          }

          // Parse ornament marking
          const ornament = parseOrnamentFromNotations(noteChildren)
          if (ornament) stats.addOrnament()

          // Flush pending grace notes → steal time from this main note
          const { graceEvents, adjustedStart, adjustedDuration } = flushGraceBuffer(
            pendingGrace, t, durSec, eventsRaw.length
          )
          for (const ge of graceEvents) eventsRaw.push(ge)
          pendingGrace = []

          eventsRaw.push({
            id: `m${mi + 1}-${eventsRaw.length}-${noteName}`,
            note: noteName,
            midi,
            startTime: adjustedStart,
            duration: adjustedDuration,
            hand,
            staff,
            measure: mi + 1,
            dynamic: currentDynamic,
            fingering,
            ornament,
            _tie: tie,
          })

          if (!isChord) t += durSec
        }
      }

      // Record measure boundaries (first part only)
      if (!firstPartDone) {
        measureTimestamps.push({
          measure: mi + 1,
          startSec: measureStartT,
          endSec: Math.max(t, measureStartT + 0.001),
        })
      }
    })

    firstPartDone = true
  }

  eventsRaw.sort((a, b) => a.startTime - b.startTime || a.midi - b.midi)
  const merged = mergeTies(eventsRaw)
  merged.sort((a, b) => a.startTime - b.startTime || a.midi - b.midi)

  // Expand ornaments into sub-events (trills, mordents, turns)
  const expanded = expandOrnaments(merged)
  expanded.sort((a, b) => a.startTime - b.startTime || a.midi - b.midi)

  const duration = expanded.length ? Math.max(...expanded.map((e) => e.startTime + e.duration)) : 0

  // Build measure map (playthroughIndex = 0 since no repeat expansion yet)
  const measureMap: MeasureMapEntry[] = measureTimestamps.map((m) => ({
    measure: m.measure,
    playthroughIndex: 0,
    startSec: m.startSec,
    endSec: m.endSec,
  }))

  // Finalize stats
  const finalStats = stats.getStats()
  finalStats.totalDuration = duration
  finalStats.tempoChanges = detectedBpm ? 1 : 0

  return { events: expanded, duration, measureMap, detectedBpm, timeSignature, stats: finalStats }
}

// -----------------------------
// TIMEWISE (ordered, robust)
// -----------------------------
function parseScoreTimewise(scoreChildren: any[], fallbackBpm: number): MusicXmlParseResult {
  const stats = new ParserStatsTracker()
  const measureNodes = findAll(scoreChildren, "measure")
  if (measureNodes.length === 0) throw new Error("No <measure> found")

  const eventsRaw: (MusicXmlNoteEvent & { _tie?: { start: boolean; stop: boolean } })[] = []

  const partTime = new Map<string, number>()
  const partDivisions = new Map<string, number>()
  const partBpm = new Map<string, number>()

  measureNodes.forEach((mNode, mi) => {
    const measureChildren = asArray(mNode["measure"]) as any[]
    const partNodes = findAll(measureChildren, "part")

    for (const partNode of partNodes) {
      const partAttrs = getAttrs(partNode)
      const partId = String(partAttrs.id ?? "P1")

      let t = partTime.get(partId) ?? 0
      let divisionsPerQuarter = partDivisions.get(partId) ?? 1
      let bpm = partBpm.get(partId) ?? fallbackBpm
      let pendingGraceTw: GraceBuffer[] = []

      const partChildren = asArray(partNode["part"]) as any[]
      const tempoHere = tempoFromMeasureChildren(partChildren)
      if (tempoHere) bpm = tempoHere

      for (const item of partChildren) {
        const tag = firstTagName(item)

        if (tag === "attributes") {
          const attrsChildren = asArray(item["attributes"]) as any[]
          const divText = childText(attrsChildren, "divisions")
          if (divText) {
            const d = safeNum(divText, divisionsPerQuarter)
            if (d > 0) divisionsPerQuarter = d
          }
          continue
        }

        if (tag === "backup") {
          const bChildren = asArray(item["backup"]) as any[]
          const durText = childText(bChildren, "duration")
          const dur = safeNum(durText, 0)
          t -= durationToSeconds(dur, divisionsPerQuarter, bpm)
          continue
        }

        if (tag === "forward") {
          const fChildren = asArray(item["forward"]) as any[]
          const durText = childText(fChildren, "duration")
          const dur = safeNum(durText, 0)
          t += durationToSeconds(dur, divisionsPerQuarter, bpm)
          continue
        }

        if (tag === "note") {
          const noteChildren = asArray(item["note"]) as any[]

          // ------ Grace note detection ------
          const isGraceNote = hasChild(noteChildren, "grace")

          if (isGraceNote) {
            stats.addNote(true)
            const pitchNode = findFirst(noteChildren, "pitch")
            if (pitchNode) {
              const pitchChildren = asArray(pitchNode["pitch"]) as any[]
              const step = childText(pitchChildren, "step")
              const octaveText = childText(pitchChildren, "octave")
              if (step && octaveText !== null) {
                const alterText = childText(pitchChildren, "alter")
                const alter = alterText !== null ? safeNum(alterText, 0) : undefined
                const octave = safeNum(octaveText, 0)
                const midi = pitchToMidi(step, alter, octave)
                const staffText = childText(noteChildren, "staff")
                const staff = safeNum(staffText, 1)
                const graceNode = findFirst(noteChildren, "grace")
                const graceAttrs = graceNode ? getAttrs(graceNode) : {}
                const graceType: GraceType = graceAttrs.slash === "yes" ? "acciaccatura" : "appoggiatura"

                pendingGraceTw.push({
                  midi,
                  note: midiToNoteName(midi),
                  hand: staffToHand(staff),
                  staff,
                  measure: mi + 1,
                  graceType,
                })
              }
            }
            continue
          }

          // ------ Regular note (timewise) ------
          const durationText = childText(noteChildren, "duration")
          const durationDiv = safeNum(durationText, 0)
          if (!durationDiv) continue
          const durSec = durationToSeconds(durationDiv, divisionsPerQuarter, bpm)
          stats.addNote(false)

          if (hasChild(noteChildren, "rest")) {
            pendingGraceTw = []
            t += durSec
            continue
          }

          const pitchNode = findFirst(noteChildren, "pitch")
          if (!pitchNode) {
            t += durSec
            continue
          }

          const pitchChildren = asArray(pitchNode["pitch"]) as any[]
          const step = childText(pitchChildren, "step")
          const octaveText = childText(pitchChildren, "octave")
          if (!step || octaveText === null) {
            t += durSec
            continue
          }

          const alterText = childText(pitchChildren, "alter")
          const alter = alterText !== null ? safeNum(alterText, 0) : undefined
          const octave = safeNum(octaveText, 0)

          const midi = pitchToMidi(step, alter, octave)
          const noteName = midiToNoteName(midi)

          const staffText = childText(noteChildren, "staff")
          const staff = safeNum(staffText, 1)
          const hand = staffToHand(staff)

          const tie = getTieTypesFromNoteChildren(noteChildren)
          if (tie.start || tie.stop) stats.addTie()
          const isChord = hasChild(noteChildren, "chord")

          // Parse ornament marking
          const ornament = parseOrnamentFromNotations(noteChildren)
          if (ornament) stats.addOrnament()

          // Flush pending grace notes
          const { graceEvents, adjustedStart, adjustedDuration } = flushGraceBuffer(
            pendingGraceTw, t, durSec, eventsRaw.length
          )
          for (const ge of graceEvents) eventsRaw.push(ge)
          pendingGraceTw = []

          eventsRaw.push({
            id: `m${mi + 1}-${partId}-${eventsRaw.length}-${noteName}`,
            note: noteName,
            midi,
            startTime: adjustedStart,
            duration: adjustedDuration,
            hand,
            staff,
            measure: mi + 1,
            ornament,
            _tie: tie,
          })

          if (!isChord) t += durSec
        }
      }

      partTime.set(partId, t)
      partDivisions.set(partId, divisionsPerQuarter)
      partBpm.set(partId, bpm)
    }
  })

  eventsRaw.sort((a, b) => a.startTime - b.startTime || a.midi - b.midi)
  const merged = mergeTies(eventsRaw)
  merged.sort((a, b) => a.startTime - b.startTime || a.midi - b.midi)

  // Expand ornaments into sub-events
  const expanded = expandOrnaments(merged)
  expanded.sort((a, b) => a.startTime - b.startTime || a.midi - b.midi)

  const duration = expanded.length ? Math.max(...expanded.map((e) => e.startTime + e.duration)) : 0

  // Build basic measure map from measure nodes
  const measureMap: MeasureMapEntry[] = []
  // For timewise, we approximate measure boundaries from events
  const measureGroups = new Map<number, { min: number; max: number }>()
  for (const e of expanded) {
    const g = measureGroups.get(e.measure)
    const end = e.startTime + e.duration
    if (g) {
      g.min = Math.min(g.min, e.startTime)
      g.max = Math.max(g.max, end)
    } else {
      measureGroups.set(e.measure, { min: e.startTime, max: end })
    }
  }
  for (const [m, g] of Array.from(measureGroups.entries()).sort((a, b) => a[0] - b[0])) {
    measureMap.push({ measure: m, playthroughIndex: 0, startSec: g.min, endSec: g.max })
  }

  // Finalize stats
  const finalStats = stats.getStats()
  finalStats.totalDuration = duration

  return { events: expanded, duration, measureMap, stats: finalStats }
}
